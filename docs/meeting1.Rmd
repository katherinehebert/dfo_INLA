---
title: "Spatiotemporal modelling of White Hake populations in the Southern Gulf of the St-Lawrence"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(INLA)
library(raster)
library(animation)
```

## Prepare the data

This data is STDIF structure - a class for unstructured spatio-temporal data, with n spatial locations and times, where n observations are available, from the `spacetime` package.

The 0s actually reflect that there were no observations at that time - in other words, they are _not_ false absences, and should not be removed.

```{r load data}
explan <- readRDS("explan.RDS")
number <- readRDS("number.RDS")
gulf <- readRDS("gulf.RDS")

# STDIF = space, time, data frame, i = irregular grid
head(number@sp)
head(number@time) # it has a time zone structure!!
head(number@endTime)

# subset to species of focus
whitehake <- number
whitehake@data <- subset(whitehake@data, select = "WHITE HAKE")
```

## Data exploration

### White hake abundances 

#### Through time

```{r plot-abundances}
plot(number@endTime, number@data$`WHITE HAKE`, type = "l")
```

#### In space

```{r map-abundances}
plot(number@sp, pch = 19, cex = number@data$`WHITE HAKE`/300)
plot(gulf, add = TRUE)
```




## Step 1 - Building the meshes

This mesh size reflects the range of coordinates in space. Changing to a smaller value, like 35000, gives a more appropriate mesh.

```{r spatial-mesh}
maxEdge <- 35000
meshSpace <- inla.mesh.2d(boundary = gulf,
                          max.edge = maxEdge*c(0.5,2),
                          offset = c(10000,20000),
                          cutoff = maxEdge/2)

# plot points under the mesh, to see if it makes sense
par(mar = c(1,1,1,1))
plot(number@sp, pch = 19, cex = 0.2, col = "red")
plot(gulf, add = TRUE)
plot(meshSpace, main = "", asp = 1, add = TRUE)

# plot abundances under the mesh too
plot(number@sp, pch = 19, cex = number@data$`WHITE HAKE`/300, col = "red")
plot(gulf, add = TRUE)
plot(meshSpace, main = "", asp = 1, add = TRUE)
```

# Number of edges in the mesh
meshSpace$n
```
Time is divided into 11 bins of minutes since 1970.
```{r time-mesh}
### Time
time <- as.numeric(whitehake@endTime)/60 # Number of minutes since Jan 1, 1970 

timeBasis <- time - 884844 # Time starting at 1

# Division points
timeGr <- 11
timeSeq <- seq(min(timeBasis),
               max(timeBasis),
               length = timeGr)
# meshTime <- inla.mesh.1d(timeSeq)

# try with two extreme time points, just to simplify the model run
meshTime <- inla.mesh.1d(c(min(timeBasis),max(timeBasis)))
```

How many estimations will be carried out?
```{r complexity-mesh}
meshSpace$n * meshTime$n
```

## Step 2 - Define the stochastic partial differential equation

```{r spde}
SPDE <- inla.spde2.pcmatern(mesh=meshSpace, # where we want to estimate
                            alpha=2, # must be between 0 and 2. this makes it curved rather than too sharp
                            prior.range=c(1000, 0.5), # distance at which the prior levels off;
                            # at a range of 100m, things should level off
                            # 0.5 means this is 50% likely. this gives a weight to the priors.
                            prior.sigma=c(35, 0.5) # amount of variance where it plateaus (slide 36/41)
                            )
# basis to build spatial structure of the model

# To set prior.sigma
sd(number@data$`WHITE HAKE`)
```

## Step 3 - Priors and hyperparameters for temporal autocorrelation

```{r priors}
# Temporal autocorrelation prior
hSpec <- list(theta=list(prior='pccor1', param=c(0.2, 0.9))) 
# assuming not a lot of temporal autocorrelation (0.2) and we are fairly sure of that (0.9)

# Precision likelihood 
## (negative binomial or any distribution that has more than one parameter)
precPrior <- list(prior='pc.prec', param=c(1, 0.01))
# guessing it's 1 with a confidence of .01, which is super low.

# note ^ is not useful if using a Poisson.
```


## Step 4 - Index matrix

```{r index-matrix}
Field <- inla.spde.make.index("field", n.spde=SPDE$n.spde,
                              n.group = meshTime$n)
```


## Step 5 - A matrix

```{r a-matrix}
# For estimation
A <- inla.spde.make.A(meshSpace,
                      loc=coordinates(whitehake@sp),
                      group = timeBasis,
                      group.mesh = meshTime)
```

## Step 6 - Organise the A matrix into a list

```{r a-matrix-list}
Alist <- as.list(rep(1,3)) # list with single values
Alist[[1]] <- A
```


## Step 7 - Organise the effects (spatial autocorrelation structure and explanatory variables)

```{r org-effects}
effect <- list(Field,
               bTemp =  explan@data$bottom.temperature,
               bSal = explan@data$bottom.salinity)
```


## Step 8 - Build stack

```{r build-stack}
Stack <- inla.stack(data=list(whitehake = whitehake@data$`WHITE HAKE`),
                    A = Alist,
                    effects = effect,
                    tag="basis")
```

## Step 9 - Building the model (Finally!)

```{r build-model}
# to find the distributions that are available
inla.models()$likelihood$poisson

form <- whitehake ~ 0 + bTemp + bSal +
        f(field, # temporal autocorr
          model=SPDE, # spatial autocorr structure
          group = field.group, # how they're grouped
          control.group=list(model='ar1', hyper=hSpec) # build with model parameters
          )

model <- inla(form,
              data = inla.stack.data(Stack),
              family="gaussian",
              control.family = list(link="identity", hyper = list(theta=precPrior)),
              control.predictor=list(A=inla.stack.A(Stack), compute=TRUE, link = 1),
              control.compute=list(waic=TRUE))
```

## Interpreting the model

```{r output-model}
summary(model)
```

#### Fixed effects

This is the output you would get from a normal linear model.
- mode: mode of the parameters distribution
- kld: ????

#### Random effects

Field group is the random effect we set earlier.

#### DF

Distribution for the parameter picked with mean, sd, and credible interval

#### Predictions through space and time

```{r prediction-maps}
# Dimension of the raster
stepsize <- 1000 # choose cell size: 1000m x 1000m
rangeX <- range(meshSpace$loc[,1])
rangeY <- range(meshSpace$loc[,2])
nxy <- round(c(diff(rangeX), 
               diff(rangeY)) / stepsize)

# Define basis of the map
mapBasis <- inla.mesh.projector(meshSpace,
                               xlim = rangeX,
                               ylim = rangeY,
                               crs = crs(gulf))

# Calculate prediction
mapMean <- vector("list", length = timeGr)
map.025 <- vector("list", length = timeGr)
map.975 <- vector("list", length = timeGr)

# for every time point
for(i in 1:timeGr){
  # Model prediction
  fitMean <- inla.mesh.project(mapBasis, 
                               model$summary.random$field$mean[1:SPDE$n.spde + (i - 1) * SPDE$n.spde])
  fit.025 <- inla.mesh.project(mapBasis, 
                               model$summary.random$field$`0.025quant`[1:SPDE$n.spde + (i - 1) * SPDE$n.spde])
  fit.975 <- inla.mesh.project(mapBasis, 
                               model$summary.random$field$`0.975quant`[1:SPDE$n.spde + (i - 1) * SPDE$n.spde])
  
  # Build maps with confidence intervals
  mapMean[[i]] <- raster(t(fitMean[,ncol(fitMean):1]),
                         xmn = min(mapBasis$x), xmx = max(mapBasis$x), 
                         ymn = min(mapBasis$y), ymx = max(mapBasis$y),
                         crs = crs(gulf))
  # to check this visually: 
  # image(mapMean[[1]])
  # plot(meshSpace, add = TRUE)

  map.025[[i]] <- raster(t(fit.025[,ncol(fit.025):1]),
                         xmn = min(mapBasis$x), xmx = max(mapBasis$x), 
                         ymn = min(mapBasis$y), ymx = max(mapBasis$y),
                         crs = crs(gulf))
  
  map.975[[i]] <- raster(t(fit.975[,ncol(fit.975):1]),
                         xmn = min(mapBasis$x), xmx = max(mapBasis$x), 
                         ymn = min(mapBasis$y), ymx = max(mapBasis$y),
                         crs = crs(gulf))
    
}
  
# Convert to a rasterStack (aligns the elements of a list)
rasterMean <- stack(mapMean)
raster.025 <- stack(map.025)
raster.975 <- stack(map.975)
# to check, image()

# reorganise
for(i in 1:5){
  values(rasterMean)[,i] <- as.vector(t(mapMean[[i]]))
  values(raster.025)[,i] <- as.vector(t(map.025[[i]]))
  values(raster.975)[,i] <- as.vector(t(map.975[[i]]))
}

# Mask the region to keep only the region of interest
rasterMeanMask <- mask(rasterMean, gulf)
raster.025Mask <- mask(raster.025, gulf)
raster.975Mask <- mask(raster.975, gulf)
#image(rasterMeanMask)
#plot(gulf, add = TRUE)

# Plot the results
par(mfrow = c(5,3), mar = c(1,1,3,1))

zlimRange <- range(values(raster.025Mask[[i]]),
                   values(rasterMeanMask[[i]]),
                   values(raster.975Mask[[i]]), na.rm = TRUE)

# plot the maps!!!!
for(i in 1:5){
  plot(raster.025Mask[[i]],
       zlim = zlimRange,
       main = "2.5%")
  
  plot(rasterMeanMask[[i]],
       zlim = zlimRange,
       main = "Mean")
  
  plot(raster.975Mask[[i]],
       zlim = zlimRange,
       main = "97.5%")
}
```

Compare the models with wAIC